          sendEvent("tool_result", { tool: toolName, result });

          // Collect citations
          if (result && typeof result === "object" && "citations" in result) {
            const citations = (result as any).citations;
            if (Array.isArray(citations)) {
              allCitations.push(...citations);
            }
          }

          // Add tool result to conversation
          conversationMessages.push({
            type: "function_call_output",
            call_id: id,
            output: JSON.stringify(result),
          });

          logger.info(
            { toolName, success: true },
            "Tool executed successfully",
          );
        } catch (error) {
          logger.error(
            { toolName, error: error instanceof Error ? error.message : error },
            "Tool execution failed",
          );

          let errorMessage = "Tool execution failed";
          if (error instanceof ZodError) {
            errorMessage = `Invalid parameters: ${error.errors.map((e) => e.message).join(", ")}`;
          } else if (error instanceof Error) {
            errorMessage = error.message;
          }

          // Emit tool_error event
          sendEvent("tool_error", { tool: toolName, error: errorMessage });

          conversationMessages.push({
            type: "function_call_output",
            call_id: id,
            output: JSON.stringify({ error: errorMessage }),
          });
        }
      }

      // Continue loop to get model's response to tool results
      logger.info("Tool calls completed, requesting model response in next iteration");
      console.log(`[runModelStream] Iteration ${iterations} complete. Tool results added to conversation. Looping for AI response...`);
    }

    logger.warn({ maxIterations }, "Maximum iterations reached");
    console.log(`[runModelStream] Max iterations reached. Returning ${accumulatedResponse.length} total chars.`);
    clearInterval(heartbeatInterval);
    sendEvent("done", { citations: [...new Set(allCitations)] });
    res.end();
    return accumulatedResponse;
  } catch (error) {
    logger.error(
      { error: error instanceof Error ? error.message : error },
      "Streaming failed",
    );
    clearInterval(heartbeatInterval);
    sendEvent("error", {
      message:
        error instanceof Error ? error.message : "Unknown streaming error",
    });
    res.end();
    return accumulatedResponse;
  }
}
