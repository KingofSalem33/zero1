    return res.json({
      ok: true,
      projects,
    });
  } catch (error) {
    console.error("Error fetching projects:", error);

    if (error instanceof DatabaseError) {
      return res.status(503).json({
        error: "Database connection error. Please try again.",
        details: error.message,
      });
    }

    return res.status(500).json({
      error: "Failed to fetch projects",
    });
  }
});

// POST /api/projects/:projectId/execute-step/stream - Execute step with streaming (AI rate limited)
router.post("/:projectId/execute-step/stream", aiLimiter, async (req, res) => {
  try {
    console.log(
      "üöÄ [API] Streaming step execution request for project:",
      req.params.projectId,
    );

    const { projectId } = req.params;
    const { master_prompt, user_message } = req.body;

    if (!projectId || typeof projectId !== "string") {
      console.error("‚ùå [API] Invalid project ID:", projectId);
      return res.status(400).json({
        error: "Valid project ID is required",
      });
    }

    if (!master_prompt || typeof master_prompt !== "string") {
      console.error("‚ùå [API] Missing master prompt");
      return res.status(400).json({
        error: "Master prompt is required",
      });
    }

    const project = await orchestrator.getProjectAsync(projectId);
    if (!project) {
      console.error("‚ùå [API] Project not found:", projectId);
      return res.status(404).json({
        error: "Project not found",
      });
    }

    // Set SSE headers
    res.setHeader("Content-Type", "text/event-stream");
    res.setHeader("Cache-Control", "no-cache");
    res.setHeader("Connection", "keep-alive");

    // Use streaming execution
    await orchestrator.executeStepStreaming({
      project_id: projectId,
      master_prompt,
      user_message,
      res,
    });

    console.log("‚úÖ [API] Streaming step executed successfully");
    // Response already sent via streaming
    return;
  } catch (error) {
    console.error("‚ùå [API] Error executing streaming step:", error);
    res.write(`event: error\n`);
    res.write(
      `data: ${JSON.stringify({ error: "Failed to execute step" })}\n\n`,
    );
    res.end();
    return;
  }
});

// POST /api/projects/:projectId/execute-step - Execute step with AI guidance (AI rate limited)
router.post("/:projectId/execute-step", aiLimiter, async (req, res) => {
  try {
    console.log(
      "üöÄ [API] Step execution request for project:",
      req.params.projectId,
    );

    const { projectId } = req.params;
    const { master_prompt, user_message } = req.body;

    if (!projectId || typeof projectId !== "string") {
      console.error("‚ùå [API] Invalid project ID:", projectId);
      return res.status(400).json({
        error: "Valid project ID is required",
      });
    }

    if (!master_prompt || typeof master_prompt !== "string") {
      console.error("‚ùå [API] Missing master prompt");
      return res.status(400).json({
        error: "Master prompt is required",
      });
    }

    const project = await orchestrator.getProjectAsync(projectId);
    if (!project) {
      console.error("‚ùå [API] Project not found:", projectId);
      return res.status(404).json({
        error: "Project not found",
      });
    }

    const result = await orchestrator.executeStep({
      project_id: projectId,
      master_prompt,
      user_message,
    });

    console.log("‚úÖ [API] Step executed successfully");
    return res.json(result);
  } catch (error) {
    console.error("‚ùå [API] Error executing step:", error);

    if (error instanceof Error && error.message === "Project not found") {
      return res.status(404).json({
        error: "Project not found",
      });
    }

    if (error instanceof Error && error.message === "AI not configured") {
      return res.status(503).json({
        error: "AI service not available",
      });
    }

    return res.status(500).json({
      error: "Failed to execute step",
    });
  }
});

// POST /api/projects/:projectId/expand - Expand phase with master prompt (AI rate limited)
router.post("/:projectId/expand", aiLimiter, async (req, res) => {
  try {
    console.log(
      "üéØ [API] Phase expansion request for project:",
      req.params.projectId,
    );
    console.log("üìù [API] Input length:", req.body.thinking_input?.length || 0);

    const { projectId } = req.params;
    const { thinking_input } = req.body;

    if (!projectId || typeof projectId !== "string") {
      console.error("‚ùå [API] Invalid project ID:", projectId);
      return res.status(400).json({
        error: "Valid project ID is required",
      });
    }

    if (!thinking_input || typeof thinking_input !== "string") {
      console.error("‚ùå [API] Missing thinking input");
      return res.status(400).json({
        error: "Thinking input is required",
      });
    }

    const project = await orchestrator.getProjectAsync(projectId);
    if (!project) {
      console.error("‚ùå [API] Project not found:", projectId);
      return res.status(404).json({
        error: "Project not found",
      });
    }

    console.log("üìã [API] Project has", project.phases?.length || 0, "phases");

    const detectedPhaseId = orchestrator.detectMasterPrompt(
      thinking_input,
      project.phases,
    );

    if (detectedPhaseId) {
      console.log(
        "‚úÖ [API] Master prompt detected, expanding phase:",
        detectedPhaseId,
      );
      const result = await orchestrator.expandPhase({
        project_id: projectId,
        phase_id: detectedPhaseId,
        master_prompt_input: thinking_input,
      });

      return res.json({
        ok: true,
        phase_expanded: true,
        ...result,
      });
    } else {
      console.log("‚ùå [API] No master prompt detected");
      return res.json({
        ok: true,
        phase_expanded: false,
        message:
          "No master prompt detected - treating as general clarification",
      });
    }
  } catch (error) {
    console.error("‚ùå [API] Error expanding phase:", error);
    return res.status(500).json({
      error: "Failed to expand phase",
    });
  }
});

// GET /api/projects/:projectId/threads - Get threads for a project
router.get("/:projectId/threads", async (req, res) => {
  try {
    const { projectId } = req.params;

    if (!projectId || typeof projectId !== "string") {
      return res.status(400).json({
        error: {
          message: "Valid project ID is required",
          type: "invalid_request_error",
          param: "projectId",
          code: "missing_required_parameter",
        },
      });
    }

    const { threadService } = await import("../services/threadService");
    const threads = await threadService.listThreads(projectId);

    return res.json({
      object: "list",
      data: threads,
    });
  } catch (error) {
    console.error("Error fetching threads:", error);
    return res.status(500).json({
      error: {
        message: "Failed to fetch threads",
        type: "internal_server_error",
        code: "thread_fetch_failed",
      },
    });
  }
});

// GET /api/projects/:projectId/checkpoints - Get checkpoints for a project
router.get("/:projectId/checkpoints", async (req, res) => {
  try {
    const { projectId } = req.params;

    if (!projectId || typeof projectId !== "string") {
      return res.status(400).json({
        error: {
          message: "Valid project ID is required",
          type: "invalid_request_error",
          param: "projectId",
          code: "missing_required_parameter",
        },
      });
    }

    const { data: checkpoints, error } = await supabase
      .from("checkpoints")
      .select("*")
      .eq("project_id", projectId)
      .order("created_at", { ascending: false });

    if (error) {
      console.error("‚ùå [Projects] Checkpoint fetch error:", error);
      return res.status(500).json({
        error: {
          message: "Failed to fetch checkpoints",
          type: "internal_server_error",
          code: "checkpoint_fetch_failed",
        },
      });
    }

    return res.json({
      object: "list",
      data: checkpoints || [],
    });
  } catch (error) {
    console.error("Error fetching checkpoints:", error);
    return res.status(500).json({
      error: {
        message: "Failed to fetch checkpoints",
        type: "internal_server_error",
        code: "checkpoint_fetch_failed",
      },
    });
  }
});

// GET /api/projects/:projectId/artifacts - Get artifacts for a project
router.get("/:projectId/artifacts", async (req, res) => {
  try {
    const { projectId } = req.params;

    if (!projectId || typeof projectId !== "string") {
      return res.status(400).json({
        error: {
          message: "Valid project ID is required",
          type: "invalid_request_error",
          param: "projectId",
          code: "missing_required_parameter",
        },
      });
    }

    const { data: artifacts, error } = await supabase
      .from("artifacts")
      .select(
        `
        *,
        artifact_signals (*)
      `,
      )
      .eq("project_id", projectId)
      .order("uploaded_at", { ascending: false });

    if (error) {
      console.error("‚ùå [Projects] Artifact fetch error:", error);
      return res.status(500).json({
        error: {
          message: "Failed to fetch artifacts",
          type: "internal_server_error",
          code: "artifact_fetch_failed",
        },
      });
    }

    return res.json({
      object: "list",
      data: artifacts || [],
    });
  } catch (error) {
    console.error("Error fetching artifacts:", error);
    return res.status(500).json({
      error: {
        message: "Failed to fetch artifacts",
        type: "internal_server_error",
        code: "artifact_fetch_failed",
      },
    });
  }
});

export default router;
