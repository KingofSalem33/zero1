
      return {
        ok: true,
        response: result.text,
        citations: result.citations,
        context: {
          phase: currentPhase?.goal,
          step: currentSubstep?.label,
          project_goal: project.goal,
        },
      };
    } catch (error) {
      console.error("‚ùå [EXECUTE] AI request failed:", error);
      throw new Error("Failed to process master prompt with AI");
    }
  }

  async executeStepStreaming(request: {
    project_id: string;
    master_prompt: string;
    user_message?: string;
    thread_id?: string;
    res: Response;
  }): Promise<void> {
    console.log(
      "üöÄ [EXECUTE] Processing streaming master prompt for project:",
      request.project_id,
    );

    const project = await this.getProjectAsync(request.project_id);
    if (!project) {
      throw new Error("Project not found");
    }

    const client = makeOpenAI();
    if (!client) {
      throw new Error("AI not configured");
    }

    // Get or create thread (optional - fallback to no thread)
    let thread = null;
    let useThreads = true;
    let accumulatedResponse = ""; // Accumulate AI response to save later

    try {
      thread = request.thread_id
        ? await threadService.getThread(request.thread_id)
        : await threadService.getOrCreateThread(request.project_id);

      // üîÑ SUBSTEP CHANGE DETECTION
      // Check if we've moved to a different substep since the last message
      if (thread && thread.context?.last_substep_context) {
        const lastPhase = thread.context.last_substep_context.phase;
        const lastSubstep = thread.context.last_substep_context.substep;
        const currentPhaseId =
          project.phases.find((p) => p.phase_number === project.current_phase)
            ?.phase_id || "";
        const currentSubstepNum = project.current_substep;

        if (lastPhase !== currentPhaseId || lastSubstep !== currentSubstepNum) {
          console.log(
            `üìç [SUBSTEP CHANGE] Detected transition from ${lastPhase}/${lastSubstep} ‚Üí ${currentPhaseId}/${currentSubstepNum}`,
          );

          // üéâ INJECT CELEBRATION/BRIEFING DIVIDER
          // Get the completed and next phase/substep objects
          const completedPhaseObj = project.phases.find(
            (p) => p.phase_id === lastPhase,
          );
          const completedSubstepObj = completedPhaseObj?.substeps?.find(
            (s: any) => s.step_number === lastSubstep,
          );
          const nextPhaseObj = project.phases.find(
            (p) => p.phase_number === project.current_phase,
          );
          const nextSubstepObj = nextPhaseObj?.substeps?.find(
            (s: any) => s.step_number === project.current_substep,
          );

          if (
            completedPhaseObj &&
            completedSubstepObj &&
            nextPhaseObj &&
            nextSubstepObj
          ) {
            const transitionMessages =
              celebrationBriefingHelper.generateTransitionMessage(
                completedPhaseObj,
                completedSubstepObj,
                nextPhaseObj,
                nextSubstepObj,
              );

            // Save celebration message
            await threadService.saveMessage(
              thread.id,
              "system",
              transitionMessages.celebration,
            );

            // Save divider + briefing as a single message
            await threadService.saveMessage(
              thread.id,
              "system",
              transitionMessages.divider + "\n" + transitionMessages.briefing,
            );

            console.log("‚úÖ [CELEBRATION] Injected transition messages");
          }
        }
      }

      // Save user message
      if (request.user_message && thread) {
        await threadService.saveMessage(
          thread.id,
          "user",
          request.user_message,
        );

        // Auto-generate title if this is the first message
        const messages = await threadService.getRecentMessages(thread.id, 1);
        if (messages.length === 1) {
          await threadService.generateTitle(thread.id, request.user_message);
        }

        // üîç CHECK FOR EXPLICIT COMPLETION REQUEST
        if (
          completionDetector.isExplicitCompletionRequest(request.user_message)
        ) {
          console.log(
            "‚úÖ [COMPLETION] User explicitly requested to mark substep complete",
          );
          // The actual completion will be handled by the complete endpoint
          // But we can log it here for awareness
        }
      }
    } catch (error) {
      console.warn(
        "‚ö†Ô∏è [EXECUTE] Thread service unavailable, proceeding without threads:",
        error,
      );
      useThreads = false;
    }

    // Get current context
    const currentPhase = project.phases.find(
      (p) => p.phase_number === project.current_phase,
    );
    const currentSubstep = currentPhase?.substeps?.find(
      (s) => s.step_number === project.current_substep,
    );

    // Get completed substeps from current phase for context continuity
    const completedSubsteps =
      currentPhase?.substeps
        ?.filter(
          (s: any) =>
            s.completed && s.step_number < (currentSubstep?.step_number || 0),
        )
        .map((s: any) => `- ${s.label} (Substep ${s.step_number})`)
        .join("\n") || "None yet - this is the first substep";

    const systemMessage = `You are helping with project execution.

When using web_search or http_fetch tools:
1. Synthesize information from multiple sources into a comprehensive answer
2. Provide specific details, examples, and actionable insights
3. Present information naturally in paragraph form, not as a list of links
4. The system will automatically display citations at the end - don't mention URLs in your response

Provide comprehensive, helpful responses using the tools when appropriate. Be conversational and thorough like ChatGPT.

After providing your response, ask the immediate next logical question to aid the user in completing the task. Be direct and specific - focus on the exact next action needed.

PROJECT CONTEXT:
- Goal: ${project.goal}
- Current Phase: ${currentPhase?.goal || "Unknown"}
- Current Step: ${currentSubstep?.label || "Unknown"}

COMPLETED SUBSTEPS IN THIS PHASE:
${completedSubsteps}

IMPORTANT: Build upon the work completed in previous substeps. Reference their outputs when relevant. Ensure continuity and avoid asking for information that was already provided in earlier substeps.

MASTER PROMPT FROM SYSTEM:
${request.master_prompt}`;

    const userMessage =
      request.user_message ||
      "Please help me with this step. Provide detailed, actionable guidance to help me complete this specific step. Be practical and specific to my project context.";

    try {
      let contextMessages: any[];

      if (useThreads && thread) {
        // Build context with recent history (with automatic token trimming)
        const rawMessages = await threadService.buildContextMessages(
          thread.id,
          systemMessage,
          ENV.OPENAI_MODEL_NAME,
        );

        // Filter out any malformed function_call messages
        // Only allow: system, user, assistant with text content
        // Function calls should never come from thread history
        contextMessages = rawMessages.filter((msg: any) => {
          // Keep system, user, assistant messages
          if (msg.role === "system" || msg.role === "user" || msg.role === "assistant") {
            return true;
          }
          // Filter out function_call and function_call_output messages
          if (msg.type === "function_call" || msg.type === "function_call_output") {
            console.warn("[ORCHESTRATOR] Filtered out malformed function message from thread history:", msg);
            return false;
          }
          return true;
        });

        // Add current user message if not already in history
        if (request.user_message) {
          contextMessages.push({
            role: "user" as const,
            content: userMessage,
          });
        }
      } else {
        // Fallback: simple message without history
        contextMessages = [
          {
            role: "system" as const,
            content: systemMessage,
          },
          {
            role: "user" as const,
            content: userMessage,
          },
        ];
      }

      // Dynamically select relevant tools based on user message
      const { toolSpecs: selectedSpecs, toolMap: selectedMap } =
        selectRelevantTools(userMessage);

      accumulatedResponse = await runModelStream(request.res, contextMessages, {
        toolSpecs: selectedSpecs,
        toolMap: selectedMap,
        model: ENV.OPENAI_MODEL_NAME,
      });

      console.log("‚úÖ [EXECUTE] Streaming AI response generated successfully");

      // Save AI response to thread
      if (useThreads && thread && accumulatedResponse) {
        try {
          await threadService.saveMessage(
            thread.id,
            "assistant",
            accumulatedResponse,
          );
          console.log("‚úÖ [EXECUTE] AI response saved to thread");

          // üìç UPDATE SUBSTEP CONTEXT IN THREAD CONTEXT
          // This enables substep change detection on next message
          const currentPhaseId = currentPhase?.phase_id || "";
          const currentSubstepNum = project.current_substep;

          await threadService.updateContext(thread.id, {
            last_substep_context: {
              phase: currentPhaseId,
              substep: currentSubstepNum,
            },
          });
          console.log(
            `üìç [CONTEXT] Saved substep context: ${currentPhaseId}/${currentSubstepNum}`,
          );
        } catch (saveError) {
          console.error(
            "‚ö†Ô∏è [EXECUTE] Failed to save AI response to thread:",
            saveError,
          );
        }
      }
    } catch (error) {
      console.error("‚ùå [EXECUTE] Streaming AI request failed:", error);
      throw error;
    }
  }

  async expandPhase(request: {
    project_id: string;
    phase_id: string;
    master_prompt_input: string;
  }): Promise<any> {
    const project = await this.getProjectAsync(request.project_id);
    if (!project) {
      throw new Error("Project not found");
    }

    const phase = project.phases.find(
